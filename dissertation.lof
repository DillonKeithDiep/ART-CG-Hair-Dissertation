\addvspace {10\p@ }
\contentsline {figure}{\numberline {1.1}{\ignorespaces Image of hair geometry.}}{1}{figure.1.1}
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces example polygon hair mesh training data.}}{13}{figure.3.1}
\contentsline {figure}{\numberline {3.2}{\ignorespaces (a) the original training mesh, (b) a partially retopologised mesh after tri-to-quad conversion operation, (c) a fully retopologised mesh after manually completing the conversion.}}{14}{figure.3.2}
\contentsline {figure}{\numberline {3.3}{\ignorespaces 3D spherical coordinate system}}{14}{figure.3.3}
\contentsline {figure}{\numberline {3.4}{\ignorespaces Sphere meshes visualise root positions. The angle ranges specify coverage area of the scalp, while the interval of placements determines resolution. Fitting a sphere to the reference head mesh approximates the radial distance and origin.}}{15}{figure.3.4}
\contentsline {figure}{\numberline {3.5}{\ignorespaces A possible configuration of 10260 parameters in the generative model, rendered on Plotly.}}{15}{figure.3.5}
\contentsline {figure}{\numberline {3.6}{\ignorespaces Our edge loop extraction algorithm begins by selecting an edge within the mesh graph. The two vertices of the edge are \textbf {end vertices}. We then proceed to \textit {grow} the edge loop selection. Take the set of \textbf {first degree neighbours} of the \textit {end vertices}, these nodes are the \textit {candidates} for the edge loop. We remove edges that are part of the current edge loop from this set of first degree neighbours. We add the first degree neighbours to a set of face vertices for following iterations. Take the neighbours of the first degree neighbours as a set of \textbf {second degree neighbours}, removing its originating end vertex. A candidate node is only accepted to the edge loop if its set neighbours do not intersect with the set of face vertices. Accepted vertices are appended to the list of end vertices, this process is repeated until there are no end vertices left to grow the selection.}}{16}{figure.3.6}
\contentsline {figure}{\numberline {3.7}{\ignorespaces Observe that the corner vertices have two edges, and the boundary edges have three. Determining the root edge loop is done by choosing the boundary edge loop that is closest to the scalp surface.}}{17}{figure.3.7}
\contentsline {figure}{\numberline {3.8}{\ignorespaces Comparison of selection operators}}{18}{figure.3.8}
\contentsline {figure}{\numberline {3.9}{\ignorespaces GPy offers various standard kernels. Multi-modal kernels can be formed from combining kernels to represent data of complex nature.}}{19}{figure.3.9}
\contentsline {figure}{\numberline {3.10}{\ignorespaces As expected, a linearly embedded hairstyle is of little use as it can only extrapolate along one style. }}{19}{figure.3.10}
\contentsline {figure}{\numberline {3.11}{\ignorespaces Blender Latent Hair Modelling Add-on}}{20}{figure.3.11}
\addvspace {10\p@ }
\addvspace {10\p@ }
\addvspace {10\p@ }
